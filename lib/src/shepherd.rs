use anyhow::Context;
use serde::{Deserialize, Serialize};
use std::{
    ffi::OsStr,
    process::{Child, ChildStdin, ChildStdout, Command, Stdio},
};

use crate::{
    feed::{Feed, Responses},
    graph::Simulation,
    ids::{EpochId, SheepId, TagId},
    simulation::Epoch,
};

/// A wrapper around a child process which implements a feed algorithm
pub struct Shepherd<'de> {
    process: Child,
    stdin: ChildStdin,
    stdout: serde_json::StreamDeserializer<
        'de,
        serde_json::de::IoRead<ChildStdout>,
        ShepherdEvent,
    >,
}

impl<'de> Shepherd<'de> {
    /// Create a new [`Shepherd`] from a command name or path
    pub fn new(program: impl AsRef<OsStr>) -> anyhow::Result<Self> {
        let mut process = Command::new(program)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .context("Unable to spawn a shepherd process")?;

        let stdin = process.stdin.take().context(
            "Unable to extract the stdin handle from the shepherd process",
        )?;
        let stdout = process.stdout.take().context(
            "Unable to extract the stdout handle from the shepherd process",
        )?;

        Ok(Self {
            process,
            stdin,
            stdout: serde_json::Deserializer::from_reader(stdout).into_iter(),
        })
    }

    /// Stop the [`Shepherd`]'s underlying process
    pub fn stop(mut self) -> anyhow::Result<()> {
        self.process
            .kill()
            .context("Unable to stop the shepherd process")
    }

    /// Write an arbitrary [`SimulationEvent`] to this [`Shepherd`]'s
    /// standard input
    pub fn write_event(&mut self, event: &SimulationEvent) {
        serde_json::to_writer(&self.stdin, event)
            .expect("Unable to pass an event to the shepherd process")
    }

    /// Read the next [`ShepherdEvent`] from this [`Shepherd`]'s
    /// standard output
    pub fn read_event(&mut self) -> ShepherdEvent {
        self.stdout
            .next()
            .expect("Unable to read an event from the shepherd process")
            .expect("Unable to read an event from the shepherd process")
    }

    /// Request that this [`Shepherd`] build a feed for the specified sheep
    /// and wait for it to return the feed
    pub fn build_feed(&mut self, sheep: SheepId) -> Feed {
        self.write_event(&SimulationEvent::FeedRequest { sheep });
        match self.read_event() {
            ShepherdEvent::Feed(feed) => feed,
        }
    }

    /// Give this [`Shepherd`] responses to a feed generated by it for the
    /// specified sheep
    pub fn incorporate_responses(
        &mut self,
        sheep: SheepId,
        responses: Responses,
    ) {
        self.write_event(&SimulationEvent::FeedResponses { sheep, responses })
    }

    /// Notify this [`Shepherd`] of the start of a new epoch
    pub fn begin(&mut self, id: EpochId, data: Epoch) {
        self.write_event(&SimulationEvent::BeginEpoch { id, data })
    }

    /// Introduce this [`Shepherd`] to a sheep
    pub fn introduce_to(&mut self, graph: &Simulation, sheep: SheepId) {
        self.write_event(&SimulationEvent::SheepIntroduction {
            sheep,
            associated_tags: graph.associated_tags(sheep).collect(),
        })
    }
}

#[non_exhaustive]
#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]
#[serde(tag = "kind", content = "data")]
pub enum SimulationEvent {
    BeginEpoch {
        id: EpochId,
        data: Epoch,
    },
    SheepIntroduction {
        sheep: SheepId,
        associated_tags: Vec<TagId>,
    },
    FeedRequest {
        sheep: SheepId,
    },
    FeedResponses {
        sheep: SheepId,
        responses: Responses,
    },
}

#[non_exhaustive]
#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]
#[serde(tag = "kind", content = "data")]
pub enum ShepherdEvent {
    Feed(Feed),
}
